<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>pcgsepy.common.api_call API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pcgsepy.common.api_call</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import json
import os
import random
from enum import Enum
from typing import Any, Dict, List, Optional, Tuple

from pcgsepy.common.jsonrpc import TransportTcpIp
from pcgsepy.common.vecs import Vec
from pcgsepy.config import HOST, PORT


class GameMode(Enum):
    &#34;&#34;&#34;Enum for the game mode.&#34;&#34;&#34;
    PLACING = False
    EVALUATING = True


def generate_json(method: str,
                  params: Optional[List[Any]] = [],
                  request_id: int = random.getrandbits(32)) -&gt; Dict[str, Any]:
    &#34;&#34;&#34;Create the JSONRPC-compatible JSON data

    Args:
        method (str): The Space Engineer&#39;s API method name.
        params (Optional[List[Any]], optional): Additional method&#39;s parameters. Defaults to `[]`.
        request_id (int, optional): Unique ID of the request. Defaults to `random.getrandbits(32)`.

    Returns:
        Dict[str, Any]: The JSONRPC-compatible JSON data
    &#34;&#34;&#34;
    return {
        &#34;jsonrpc&#34;: &#34;2.0&#34;,
        &#34;method&#34;: method,
        &#34;params&#34;: params,
        &#34;id&#34;: request_id
    }


def compactify_jsons(jsons: List[Dict[str, Any]]) -&gt; str:
    &#34;&#34;&#34;Compactify JSON data. Removes any space in the JSOn and uses no indentation.

    Args:
        jsons (List[Dict[str, Any]]): The JSON data to compactify.

    Returns:
        List[str]: The compacted JSON data.
    &#34;&#34;&#34;
    return &#39;\r\n&#39;.join([f&#34;{json.dumps(obj=j, separators=(&#39;,&#39;, &#39;:&#39;), indent=None)}&#34; for j in jsons]) + &#39;\r\n&#39;


def call_api(host: str = HOST,
             port: int = PORT,
             jsons: List[Dict[str, Any]] = {}) -&gt; List[Dict[str, Any]]:
    &#34;&#34;&#34;Call the Space Engineer&#39;s API.

    Args:
        host (str, optional): The host address . Defaults to `HOST`.
        port (int, optional): The port number. Defaults to `PORT`.
        jsons (List[Dict[str, Any]], optional): The list of methods and parameters as a list of JSONs. Defaults to `{}`.

    Returns:
        List[Dict[str, Any]]: The data returned from the Space Engineer&#39;s API.
    &#34;&#34;&#34;
    s = TransportTcpIp(addr=(host, port),
                       timeout=2,
                       limit=4096)
    res = s.sendrecv(string=compactify_jsons(jsons=jsons).encode(&#39;utf-8&#39;)).decode(encoding=&#39;utf-8&#39;)
    return json.loads(res)


# block_definitions as a module-level variable
if not os.path.exists(&#39;./block_definitions.json&#39;):
    # poll API for block definition ids
    jsons = [generate_json(method=&#34;Definitions.BlockDefinitions&#34;)]
    res = call_api(jsons=jsons)
    block_definitions = {}
    for v in res[&#39;result&#39;]:
        block_definitions[&#39;_&#39;.join([v[&#39;DefinitionId&#39;][&#39;Id&#39;],
                                    v[&#39;DefinitionId&#39;][&#39;Type&#39;]])] = {
            &#39;cube_size&#39;: v[&#39;CubeSize&#39;],
            &#39;size&#39;: v[&#39;Size&#39;],
            &#39;mass&#39;: v[&#39;Mass&#39;],
            &#39;definition_id&#39;: {&#39;Id&#39;: v[&#39;DefinitionId&#39;][&#39;Id&#39;],
                              &#39;Type&#39;: v[&#39;DefinitionId&#39;][&#39;Type&#39;]},
            &#39;mountpoints&#39;: v[&#39;MountPoints&#39;]
        }
    with open(&#39;./block_definitions.json&#39;, &#39;w&#39;) as f:
        json.dump(block_definitions, f)
else:
    with open(&#39;./block_definitions.json&#39;, &#39;r&#39;) as f:
        block_definitions = json.load(f)


def get_base_values() -&gt; Tuple[Vec, Vec, Vec]:
    &#34;&#34;&#34;Get the position, orientation forward and orientation up of the player.

    Returns:
        Tuple[Vec, Vec, Vec]: The data as tuple of `Vec`s
    &#34;&#34;&#34;
    obs = call_api(jsons=[generate_json(method=&#34;Observer.Observe&#34;)])
    return Vec.from_json(obs[&#39;result&#39;][&#39;Position&#39;]), Vec.from_json(obs[&#39;result&#39;][&#39;OrientationForward&#39;]), Vec.from_json(obs[&#39;result&#39;][&#39;Camera&#39;][&#39;OrientationUp&#39;])


def toggle_gamemode(mode: GameMode) -&gt; None:
    &#34;&#34;&#34;Switch between `GameMode.PLACING` (fast) and `GameMode.EVALUATING` (slow). This could become deprecated in the future.

    Args:
        mode (GameMode): The game mode to toggle.
    &#34;&#34;&#34;
    call_api(jsons=[generate_json(method=&#34;Admin.SetFrameLimitEnabled&#34;,
                                  params=[mode.value])])


def get_batch_ranges(batch_size: int,
                     length: int,
                     drop_last: bool = False) -&gt; List[Tuple[int, int]]:
    &#34;&#34;&#34;Get the index ranges for batch iterations of an iterable object.

    Args:
        batch_size (int): The size of the batch.
        length (int): The length of the iterable.
        drop_last (bool, optional): Whether to drop the last batch if `&lt; batch_size`. Defaults to False.

    Returns:
        List[Tuple[int, int]]: The index ranges for batch iterations.
    &#34;&#34;&#34;
    def __offset(batch_size: int,
                 length: int,
                 batch_n: int) -&gt; int:
        &#34;&#34;&#34;Compute the batch offset.

        Args:
            batch_size (int): The size of the batch.
            length (int): The length of the iterable.
            batch_n (int): The current batch number.

        Returns:
            int: The offset.
        &#34;&#34;&#34;
        return batch_size if (length &gt; (batch_n + 1) * batch_size) else batch_size - ((batch_n + 1) * batch_size - length)
    return [(batch_n * batch_size, batch_n * batch_size + __offset(batch_size=batch_size,
                                                                   length=length,
                                                                   batch_n=batch_n)) for batch_n in range(0, (length // batch_size) + (0 if (length % batch_size == 0 or drop_last) else 1))]


def place_blocks(blocks: List[Any],
                 sequential: False) -&gt; None:
    &#34;&#34;&#34;Place the blocks in-game.

    Args:
        blocks (List[Block]): The list of blocks.
        sequential (bool): Flag to either make the `Admin.Blocks.PlaceAt` call for each block or for the entire list.
    &#34;&#34;&#34;
    # prepare jsons
    jsons = [generate_json(
        method=&#39;Admin.Blocks.PlaceAt&#39;,
        params={
            &#34;blockDefinitionId&#34;: block.definition_id,
            &#34;position&#34;: block.position.as_dict(),
            &#34;orientationForward&#34;: block.orientation_forward.as_dict(),
            &#34;orientationUp&#34;: block.orientation_up.as_dict(),
            &#34;color&#34;: block.color.as_dict() if block.color else None,
            }) for block in blocks]
    # place blocks
    if not sequential:
        call_api(jsons=jsons)
    else:
        for j in jsons:
            call_api(jsons=j)

# TODO: This code is currently unused

# def rotate_and_normalize_block(rotation_matrix: np.ndarray,
#                                normalizing_block: Block,
#                                block: Block,
#                                to_int: bool = True) -&gt; Tuple[Vec, Vec, Vec]:
#     of = rotate(rotation_matrix=rotation_matrix,
#                 vector=block.orientation_forward)
#     ou = rotate(rotation_matrix=rotation_matrix,
#                 vector=block.orientation_up)

#     pos = block.position.sum(normalizing_block.position.scale(-1))
#     pos = rotate(rotation_matrix=rotation_matrix,
#                 vector=pos)

#     return (of.to_veci(), ou.to_veci(), pos.to_veci()) if to_int else (of, ou, pos)


# def try_place_block(block: Block,
#                     rotation_matrix: npt.NDArray,
#                     normalizing_block: Block,
#                     grid_id: str) -&gt; bool:
#     of, ou, pos = rotate_and_normalize_block(rotation_matrix=rotation_matrix,
#                                             normalizing_block=normalizing_block,
#                                             block=block,
#                                             to_int=True)
#     res = call_api(jsons=[
#         generate_json(method=&#39;Admin.Blocks.PlaceInGrid&#39;,
#                     params={
#                         &#34;blockDefinitionId&#34;: block_definitions[block.block_type][&#39;definition_id&#39;],
#                         &#34;gridId&#34;: grid_id,
#                         &#34;minPosition&#34;: pos.as_dict(),
#                         &#34;orientationForward&#34;: of.as_dict(),
#                         &#34;orientationUp&#34;: ou.as_dict()
#                     })
#     ])
#     return res[0].get(&#39;error&#39;, None) is None


# class PlacementException(Exception):
#     pass


# def place_structure(structure: Structure,
#                     position: Vec,
#                     orientation_forward: Vec = Orientation.FORWARD.value,
#                     orientation_up: Vec = Orientation.UP.value,
#                     batchify: bool = True) -&gt; None:
#     &#34;&#34;&#34;
#     Place the structure in-game.

#     Parameters
#     ----------
#     structure : Structure
#         The structure to place.
#     position : Vec
#         The minimum position of the structure to place at.
#     orientation_forward : Vec
#         The Forward orientation, as vector.
#     orientation_up : Vec
#         The Up orientation, as vector.
#     &#34;&#34;&#34;
#     # ensure structure position and orientation
#     structure.update(
#         origin=Vec.v3f(0., 0., 0.),
#         orientation_forward=orientation_forward,
#         orientation_up=orientation_up,
#     )
#     structure.sanify()
#     to_place = structure.get_all_blocks(to_place=False)
#     # toggle gamemode to place faster
#     toggle_gamemode(GameMode.PLACING)
#     # get lowest-index block in structure
#     first_block = None
#     for block in to_place:
#         if first_block:
#             if block.position.x &lt;= first_block.position.x and block.position.y &lt;= first_block.position.y and block.position.z &lt;= first_block.position.z:
#                 first_block = block
#         else:
#             first_block = block
#     # remove first block from list
#     to_place.remove(first_block)
#     # place first block
#     call_api(jsons=[
#         generate_json(
#             method=&#39;Admin.Blocks.PlaceAt&#39;,
#             params={
#                 &#34;blockDefinitionId&#34;: block_definitions[first_block.block_type][&#39;definition_id&#39;],
#                 &#34;position&#34;: position.as_dict(),
#                 &#34;orientationForward&#34;: first_block.orientation_forward.as_dict(),
#                 &#34;orientationUp&#34;: first_block.orientation_up.as_dict()
#             })
#     ])
#     # get placed block&#39;s grid
#     observation = call_api(jsons=[generate_json(method=&#39;Observer.ObserveBlocks&#39;, params={})])
#     grid_id = observation[0][&#34;result&#34;][&#34;Grids&#34;][0][&#34;Id&#34;]
#     grid_orientation_forward = Vec.from_json(observation[0][&#34;result&#34;][&#34;Grids&#34;][0][&#34;OrientationForward&#34;])
#     grid_orientation_up = Vec.from_json(observation[0][&#34;result&#34;][&#34;Grids&#34;][0][&#34;OrientationUp&#34;])
#     rotation_matrix = get_rotation_matrix(forward=grid_orientation_forward,
#                                         up=grid_orientation_up)

#     # TODO: Move character away so that the spaceship can be built entirely

#     # reorder blocks
#     occupied_space = [first_block.position]
#     ordered_blocks = []
#     while to_place:
#         to_rem = []
#         for block in to_place:
#             if (block.position.sum(Vec.v3i(-1, 0, 0)) in occupied_space or
#                 block.position.sum(Vec.v3i(0, -1, 0)) in occupied_space or
#                 block.position.sum(Vec.v3i(0, 0, -1)) in occupied_space or
#                 block.position.sum(Vec.v3i(1, 0, 0)) in occupied_space or
#                 block.position.sum(Vec.v3i(0, 1, 0)) in occupied_space or
#                 block.position.sum(Vec.v3i(0, 0, 1)) in occupied_space):
#                 to_rem.append(block)
#                 occupied_space.append(block.position)
#                 ordered_blocks.append(block)
#         for r in to_rem:
#             to_place.remove(r)
#     if batchify:
#         # attempt placement in batches
#         batch_size = 64
#         jsons = []
#         for n, block in enumerate(ordered_blocks):
#             of, ou, pos = rotate_and_normalize_block(rotation_matrix=rotation_matrix,
#                                                     normalizing_block=first_block,
#                                                     block=block,
#                                                     to_int=True)
#             jsons.append(generate_json(method=&#39;Admin.Blocks.PlaceInGrid&#39;,
#                                        params={
#                                            &#34;blockDefinitionId&#34;: block_definitions[block.block_type][&#39;definition_id&#39;],
#                                            &#34;gridId&#34;: grid_id,
#                                            &#34;minPosition&#34;: pos.as_dict(),
#                                            &#34;orientationForward&#34;: of.as_dict(),
#                                            &#34;orientationUp&#34;: ou.as_dict()},
#                                        request_id=n))
#         n_requests = 0
#         while jsons:
#             to_rem = []
#             for (idx_from, idx_to) in get_batch_ranges(batch_size=batch_size,
#                                                        length=len(jsons)):
#                 res_list = call_api(jsons=jsons[idx_from:idx_to])
#                 for res in res_list:
#                     if res.get(&#39;error&#39;, None) is None:
#                         to_rem.append(res)
#             for res in to_rem:
#                 for i, req in enumerate(jsons):
#                     if req[&#39;id&#39;] == res[&#39;id&#39;]:
#                         jsons.pop(i)
#                         break
#             if len(jsons) == n_requests:
#                 raise PlacementException(f&#39;Error during spaceship placement: missing {len(jsons)} blocks to place.&#39;)
#             else:
#                 n_requests = len(jsons)
#     else:
#         # attempt placement sequentially
#         errored_out = []
#         for block in ordered_blocks:
#             # always try to place blocks that we failed to place previously
#             to_rem = []
#             for b in errored_out:
#                 res = try_place_block(block=b,
#                                     rotation_matrix=rotation_matrix,
#                                     normalizing_block=first_block,
#                                     grid_id=grid_id)
#                 if res:
#                     to_rem.append(b)
#             for b in to_rem:
#                 errored_out.remove(b)
#             # try and place current block
#             res = try_place_block(block=block,
#                                 rotation_matrix=rotation_matrix,
#                                 normalizing_block=first_block,
#                                 grid_id=grid_id)
#             if not res:
#                 errored_out.append(block)
#         if len(errored_out) != 0:
#             raise PlacementException(f&#39;Error during spaceship placement: missing {len(errored_out)} blocks to place.&#39;)
#     # toggle back gamemode
#     toggle_gamemode(GameMode.EVALUATING)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="pcgsepy.common.api_call.call_api"><code class="name flex">
<span>def <span class="ident">call_api</span></span>(<span>host: str = 'localhost', port: int = 3333, jsons: List[Dict[str, Any]] = {}) ‑> List[Dict[str, Any]]</span>
</code></dt>
<dd>
<div class="desc"><p>Call the Space Engineer's API.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>host</code></strong> :&ensp;<code>str</code>, optional</dt>
<dd>The host address . Defaults to <code>HOST</code>.</dd>
<dt><strong><code>port</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The port number. Defaults to <code>PORT</code>.</dd>
<dt><strong><code>jsons</code></strong> :&ensp;<code>List[Dict[str, Any]]</code>, optional</dt>
<dd>The list of methods and parameters as a list of JSONs. Defaults to <code>{}</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List[Dict[str, Any]]</code></dt>
<dd>The data returned from the Space Engineer's API.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def call_api(host: str = HOST,
             port: int = PORT,
             jsons: List[Dict[str, Any]] = {}) -&gt; List[Dict[str, Any]]:
    &#34;&#34;&#34;Call the Space Engineer&#39;s API.

    Args:
        host (str, optional): The host address . Defaults to `HOST`.
        port (int, optional): The port number. Defaults to `PORT`.
        jsons (List[Dict[str, Any]], optional): The list of methods and parameters as a list of JSONs. Defaults to `{}`.

    Returns:
        List[Dict[str, Any]]: The data returned from the Space Engineer&#39;s API.
    &#34;&#34;&#34;
    s = TransportTcpIp(addr=(host, port),
                       timeout=2,
                       limit=4096)
    res = s.sendrecv(string=compactify_jsons(jsons=jsons).encode(&#39;utf-8&#39;)).decode(encoding=&#39;utf-8&#39;)
    return json.loads(res)</code></pre>
</details>
</dd>
<dt id="pcgsepy.common.api_call.compactify_jsons"><code class="name flex">
<span>def <span class="ident">compactify_jsons</span></span>(<span>jsons: List[Dict[str, Any]]) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Compactify JSON data. Removes any space in the JSOn and uses no indentation.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>jsons</code></strong> :&ensp;<code>List[Dict[str, Any]]</code></dt>
<dd>The JSON data to compactify.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List[str]</code></dt>
<dd>The compacted JSON data.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compactify_jsons(jsons: List[Dict[str, Any]]) -&gt; str:
    &#34;&#34;&#34;Compactify JSON data. Removes any space in the JSOn and uses no indentation.

    Args:
        jsons (List[Dict[str, Any]]): The JSON data to compactify.

    Returns:
        List[str]: The compacted JSON data.
    &#34;&#34;&#34;
    return &#39;\r\n&#39;.join([f&#34;{json.dumps(obj=j, separators=(&#39;,&#39;, &#39;:&#39;), indent=None)}&#34; for j in jsons]) + &#39;\r\n&#39;</code></pre>
</details>
</dd>
<dt id="pcgsepy.common.api_call.generate_json"><code class="name flex">
<span>def <span class="ident">generate_json</span></span>(<span>method: str, params: Optional[List[Any]] = [], request_id: int = 539360666) ‑> Dict[str, Any]</span>
</code></dt>
<dd>
<div class="desc"><p>Create the JSONRPC-compatible JSON data</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>method</code></strong> :&ensp;<code>str</code></dt>
<dd>The Space Engineer's API method name.</dd>
<dt><strong><code>params</code></strong> :&ensp;<code>Optional[List[Any]]</code>, optional</dt>
<dd>Additional method's parameters. Defaults to <code>[]</code>.</dd>
<dt><strong><code>request_id</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>Unique ID of the request. Defaults to <code>random.getrandbits(32)</code>.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Dict[str, Any]</code></dt>
<dd>The JSONRPC-compatible JSON data</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_json(method: str,
                  params: Optional[List[Any]] = [],
                  request_id: int = random.getrandbits(32)) -&gt; Dict[str, Any]:
    &#34;&#34;&#34;Create the JSONRPC-compatible JSON data

    Args:
        method (str): The Space Engineer&#39;s API method name.
        params (Optional[List[Any]], optional): Additional method&#39;s parameters. Defaults to `[]`.
        request_id (int, optional): Unique ID of the request. Defaults to `random.getrandbits(32)`.

    Returns:
        Dict[str, Any]: The JSONRPC-compatible JSON data
    &#34;&#34;&#34;
    return {
        &#34;jsonrpc&#34;: &#34;2.0&#34;,
        &#34;method&#34;: method,
        &#34;params&#34;: params,
        &#34;id&#34;: request_id
    }</code></pre>
</details>
</dd>
<dt id="pcgsepy.common.api_call.get_base_values"><code class="name flex">
<span>def <span class="ident">get_base_values</span></span>(<span>) ‑> Tuple[<a title="pcgsepy.common.vecs.Vec" href="vecs.html#pcgsepy.common.vecs.Vec">Vec</a>, <a title="pcgsepy.common.vecs.Vec" href="vecs.html#pcgsepy.common.vecs.Vec">Vec</a>, <a title="pcgsepy.common.vecs.Vec" href="vecs.html#pcgsepy.common.vecs.Vec">Vec</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Get the position, orientation forward and orientation up of the player.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Tuple[Vec, Vec, Vec]</code></dt>
<dd>The data as tuple of <code>Vec</code>s</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_base_values() -&gt; Tuple[Vec, Vec, Vec]:
    &#34;&#34;&#34;Get the position, orientation forward and orientation up of the player.

    Returns:
        Tuple[Vec, Vec, Vec]: The data as tuple of `Vec`s
    &#34;&#34;&#34;
    obs = call_api(jsons=[generate_json(method=&#34;Observer.Observe&#34;)])
    return Vec.from_json(obs[&#39;result&#39;][&#39;Position&#39;]), Vec.from_json(obs[&#39;result&#39;][&#39;OrientationForward&#39;]), Vec.from_json(obs[&#39;result&#39;][&#39;Camera&#39;][&#39;OrientationUp&#39;])</code></pre>
</details>
</dd>
<dt id="pcgsepy.common.api_call.get_batch_ranges"><code class="name flex">
<span>def <span class="ident">get_batch_ranges</span></span>(<span>batch_size: int, length: int, drop_last: bool = False) ‑> List[Tuple[int, int]]</span>
</code></dt>
<dd>
<div class="desc"><p>Get the index ranges for batch iterations of an iterable object.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>batch_size</code></strong> :&ensp;<code>int</code></dt>
<dd>The size of the batch.</dd>
<dt><strong><code>length</code></strong> :&ensp;<code>int</code></dt>
<dd>The length of the iterable.</dd>
<dt><strong><code>drop_last</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to drop the last batch if <code>&lt; batch_size</code>. Defaults to False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List[Tuple[int, int]]</code></dt>
<dd>The index ranges for batch iterations.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_batch_ranges(batch_size: int,
                     length: int,
                     drop_last: bool = False) -&gt; List[Tuple[int, int]]:
    &#34;&#34;&#34;Get the index ranges for batch iterations of an iterable object.

    Args:
        batch_size (int): The size of the batch.
        length (int): The length of the iterable.
        drop_last (bool, optional): Whether to drop the last batch if `&lt; batch_size`. Defaults to False.

    Returns:
        List[Tuple[int, int]]: The index ranges for batch iterations.
    &#34;&#34;&#34;
    def __offset(batch_size: int,
                 length: int,
                 batch_n: int) -&gt; int:
        &#34;&#34;&#34;Compute the batch offset.

        Args:
            batch_size (int): The size of the batch.
            length (int): The length of the iterable.
            batch_n (int): The current batch number.

        Returns:
            int: The offset.
        &#34;&#34;&#34;
        return batch_size if (length &gt; (batch_n + 1) * batch_size) else batch_size - ((batch_n + 1) * batch_size - length)
    return [(batch_n * batch_size, batch_n * batch_size + __offset(batch_size=batch_size,
                                                                   length=length,
                                                                   batch_n=batch_n)) for batch_n in range(0, (length // batch_size) + (0 if (length % batch_size == 0 or drop_last) else 1))]</code></pre>
</details>
</dd>
<dt id="pcgsepy.common.api_call.place_blocks"><code class="name flex">
<span>def <span class="ident">place_blocks</span></span>(<span>blocks: List[Any], sequential: False) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Place the blocks in-game.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>blocks</code></strong> :&ensp;<code>List[Block]</code></dt>
<dd>The list of blocks.</dd>
<dt><strong><code>sequential</code></strong> :&ensp;<code>bool</code></dt>
<dd>Flag to either make the <code>Admin.Blocks.PlaceAt</code> call for each block or for the entire list.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def place_blocks(blocks: List[Any],
                 sequential: False) -&gt; None:
    &#34;&#34;&#34;Place the blocks in-game.

    Args:
        blocks (List[Block]): The list of blocks.
        sequential (bool): Flag to either make the `Admin.Blocks.PlaceAt` call for each block or for the entire list.
    &#34;&#34;&#34;
    # prepare jsons
    jsons = [generate_json(
        method=&#39;Admin.Blocks.PlaceAt&#39;,
        params={
            &#34;blockDefinitionId&#34;: block.definition_id,
            &#34;position&#34;: block.position.as_dict(),
            &#34;orientationForward&#34;: block.orientation_forward.as_dict(),
            &#34;orientationUp&#34;: block.orientation_up.as_dict(),
            &#34;color&#34;: block.color.as_dict() if block.color else None,
            }) for block in blocks]
    # place blocks
    if not sequential:
        call_api(jsons=jsons)
    else:
        for j in jsons:
            call_api(jsons=j)</code></pre>
</details>
</dd>
<dt id="pcgsepy.common.api_call.toggle_gamemode"><code class="name flex">
<span>def <span class="ident">toggle_gamemode</span></span>(<span>mode: <a title="pcgsepy.common.api_call.GameMode" href="#pcgsepy.common.api_call.GameMode">GameMode</a>) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Switch between <code><a title="pcgsepy.common.api_call.GameMode.PLACING" href="#pcgsepy.common.api_call.GameMode.PLACING">GameMode.PLACING</a></code> (fast) and <code><a title="pcgsepy.common.api_call.GameMode.EVALUATING" href="#pcgsepy.common.api_call.GameMode.EVALUATING">GameMode.EVALUATING</a></code> (slow). This could become deprecated in the future.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>mode</code></strong> :&ensp;<code><a title="pcgsepy.common.api_call.GameMode" href="#pcgsepy.common.api_call.GameMode">GameMode</a></code></dt>
<dd>The game mode to toggle.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def toggle_gamemode(mode: GameMode) -&gt; None:
    &#34;&#34;&#34;Switch between `GameMode.PLACING` (fast) and `GameMode.EVALUATING` (slow). This could become deprecated in the future.

    Args:
        mode (GameMode): The game mode to toggle.
    &#34;&#34;&#34;
    call_api(jsons=[generate_json(method=&#34;Admin.SetFrameLimitEnabled&#34;,
                                  params=[mode.value])])</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pcgsepy.common.api_call.GameMode"><code class="flex name class">
<span>class <span class="ident">GameMode</span></span>
<span>(</span><span>value, names=None, *, module=None, qualname=None, type=None, start=1)</span>
</code></dt>
<dd>
<div class="desc"><p>Enum for the game mode.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class GameMode(Enum):
    &#34;&#34;&#34;Enum for the game mode.&#34;&#34;&#34;
    PLACING = False
    EVALUATING = True</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>enum.Enum</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="pcgsepy.common.api_call.GameMode.EVALUATING"><code class="name">var <span class="ident">EVALUATING</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="pcgsepy.common.api_call.GameMode.PLACING"><code class="name">var <span class="ident">PLACING</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pcgsepy.common" href="index.html">pcgsepy.common</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="pcgsepy.common.api_call.call_api" href="#pcgsepy.common.api_call.call_api">call_api</a></code></li>
<li><code><a title="pcgsepy.common.api_call.compactify_jsons" href="#pcgsepy.common.api_call.compactify_jsons">compactify_jsons</a></code></li>
<li><code><a title="pcgsepy.common.api_call.generate_json" href="#pcgsepy.common.api_call.generate_json">generate_json</a></code></li>
<li><code><a title="pcgsepy.common.api_call.get_base_values" href="#pcgsepy.common.api_call.get_base_values">get_base_values</a></code></li>
<li><code><a title="pcgsepy.common.api_call.get_batch_ranges" href="#pcgsepy.common.api_call.get_batch_ranges">get_batch_ranges</a></code></li>
<li><code><a title="pcgsepy.common.api_call.place_blocks" href="#pcgsepy.common.api_call.place_blocks">place_blocks</a></code></li>
<li><code><a title="pcgsepy.common.api_call.toggle_gamemode" href="#pcgsepy.common.api_call.toggle_gamemode">toggle_gamemode</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pcgsepy.common.api_call.GameMode" href="#pcgsepy.common.api_call.GameMode">GameMode</a></code></h4>
<ul class="">
<li><code><a title="pcgsepy.common.api_call.GameMode.EVALUATING" href="#pcgsepy.common.api_call.GameMode.EVALUATING">EVALUATING</a></code></li>
<li><code><a title="pcgsepy.common.api_call.GameMode.PLACING" href="#pcgsepy.common.api_call.GameMode.PLACING">PLACING</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>