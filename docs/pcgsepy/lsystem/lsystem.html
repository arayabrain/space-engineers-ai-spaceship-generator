<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>pcgsepy.lsystem.lsystem API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pcgsepy.lsystem.lsystem</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import itertools
import logging
from typing import Any, Dict, List, Optional, Tuple

import numpy as np
import numpy.typing as npt
from pcgsepy.common.vecs import Orientation, Vec
from pcgsepy.config import N_SPE
from pcgsepy.lsystem.constraints import ConstraintHandler
from pcgsepy.lsystem.solution import CandidateSolution, merge_solutions
from pcgsepy.lsystem.solver import LSolver
from pcgsepy.lsystem.structure_maker import LLStructureMaker
from pcgsepy.structure import Structure


class LSystemModule:
    __slots__ = [&#39;hlsolver&#39;, &#39;llsolver&#39;, &#39;check_sat&#39;,
                 &#39;name&#39;, &#39;active&#39;, &#39;hl_constraints&#39;, &#39;ll_constraints&#39;]

    def __init__(self,
                 hl_solver: LSolver,
                 ll_solver: LSolver,
                 name: str):
        &#34;&#34;&#34;Create a module of the hierarchical L-system.

        Args:
            hl_solver (LSolver): The high-level solver.
            ll_solver (LSolver): The low-level solver.
            name (str): The name of the module.
        &#34;&#34;&#34;
        self.hlsolver = hl_solver
        self.llsolver = ll_solver
        self.check_sat = True
        self.name = name
        self.active = True
        self.hl_constraints = []
        self.ll_constraints = []

    def add_hl_constraint(self,
                          c: ConstraintHandler) -&gt; None:
        &#34;&#34;&#34;Add a high-level constraint to the module.

        Args:
            c (ConstraintHandler): The constraint.
        &#34;&#34;&#34;
        self.hl_constraints.append(c)

    def add_ll_constraint(self,
                          c: ConstraintHandler) -&gt; None:
        &#34;&#34;&#34;Add a low-level constraint to the module.

        Args:
            c (ConstraintHandler): The constraint.
        &#34;&#34;&#34;
        self.ll_constraints.append(c)

    def _get_hl_solutions(self,
                          starting_string: str,
                          iterations: int = 1) -&gt; List[CandidateSolution]:
        &#34;&#34;&#34;Get the high-level solutions.

        Args:
            starting_string (str): The starting string.
            iterations (int, optional): The number of iterations to expand for. Defaults to 1.

        Returns:
            List[CandidateSolution]: The list of solutions.
        &#34;&#34;&#34;
        return self.hlsolver.solve(string=starting_string,
                                   iterations=iterations,
                                   strings_per_iteration=N_SPE,
                                   check_sat=self.check_sat)

    def _get_ml_strings(self,
                        hl_strings: List[str]) -&gt; List[str]:
        &#34;&#34;&#34;Convert the high-level strings to mid-level.

        Args:
            hl_strings (List[str]): The high-level strings.

        Returns:
            List[str]: The list of mid-level strings.
        &#34;&#34;&#34;
        return [self.hlsolver.translator.transform(string=hl_string) for hl_string in hl_strings]

    def _get_ll_solutions(self,
                          cs: List[CandidateSolution]) -&gt; Tuple[List[CandidateSolution], npt.NDArray[np.bool8]]:
        &#34;&#34;&#34;Get the low-level solutions.
        Make sure that each high-level solutions already has a mid-level string assigned.

        Args:
            cs (List[CandidateSolution]): The list of high-level solutions.

        Returns:
            Tuple[List[CandidateSolution], npt.NDArray[np.bool8]]: The list of solutions and which solutions should be kept.
        &#34;&#34;&#34;
        ll_solutions, to_keep = [], np.zeros(shape=len(cs), dtype=np.bool8)
        for i, cs in enumerate(cs):
            ll_solution = self.llsolver.solve(string=cs.string,
                                              iterations=1,
                                              strings_per_iteration=1,
                                              check_sat=self.check_sat)[0]
            if ll_solution:
                ll_solutions.append(ll_solution)
                to_keep[i] = True
        return ll_solutions, to_keep

    def apply_rules(self,
                    starting_string: str,
                    iterations: int = 1) -&gt; List[CandidateSolution]:
        &#34;&#34;&#34;Apply the rules of the module to a given starting string.

        Args:
            starting_string (str): The starting string.
            iterations (int, optional): The number of iterations to expand for. Defaults to 1.

        Returns:
            List[CandidateSolution]: The list of solutions.
        &#34;&#34;&#34;
        self.hlsolver.set_constraints(cs=self.hl_constraints)
        self.llsolver.set_constraints(cs=self.ll_constraints)
        logging.getLogger(&#39;base-logger&#39;).info(f&#39;[{self.name}] Started high level solving...&#39;)
        hl_solutions = self._get_hl_solutions(starting_string=starting_string,
                                              iterations=iterations)
        logging.getLogger(&#39;base-logger&#39;).debug(f&#39;[{self.name}] Converting HL strings to ML...&#39;)
        ml_strings = self._get_ml_strings([cs.string for cs in hl_solutions])
        logging.getLogger(&#39;base-logger&#39;).info(f&#39;[{self.name}] Started low level solving...&#39;)
        _, to_keep = self._get_ll_solutions([CandidateSolution(string=s,
                                                               content=hl_cs._content) for s, hl_cs in zip(ml_strings, hl_solutions)])
        hl_solutions = [x for x, k in zip(hl_solutions, to_keep) if k]
        return hl_solutions

    def to_json(self) -&gt; Dict[str, Any]:
        return {
            &#39;hlsolver&#39;: self.hlsolver.to_json(),
            &#39;llsolver&#39;: self.llsolver.to_json(),
            &#39;check_sat&#39;: self.check_sat,
            &#39;name&#39;: self.name,
            &#39;active&#39;: self.active,
            &#39;hl_constraints&#39;: [c.to_json() for c in self.hl_constraints],
            &#39;ll_constraints&#39;: [c.to_json() for c in self.ll_constraints],
        }

    @staticmethod
    def from_json(my_args: Dict[str, Any]) -&gt; &#39;LSystemModule&#39;:
        lsm = LSystemModule(hl_solver=LSolver.from_json(my_args[&#39;hlsolver&#39;]),
                            ll_solver=LSolver.from_json(my_args[&#39;llsolver&#39;]),
                            name=my_args[&#39;name&#39;])
        lsm.active = my_args[&#39;active&#39;]
        lsm.hl_constraints = [ConstraintHandler.from_json(c) for c in my_args[&#39;hl_constraints&#39;]]
        lsm.ll_constraints = [ConstraintHandler.from_json(c) for c in my_args[&#39;ll_constraints&#39;]]
        return lsm


class LSystem:
    def __init__(self,
                 hl_solver: LSolver,
                 ll_solver: LSolver,
                 names: List[str]):
        &#34;&#34;&#34;Create the hierarchical L-system. Each name corresponds to a L-system sub-module.

        Args:
            hl_solver (LSolver): The high-level solver.
            ll_solver (LSolver): The low-level solver.
            names (List[str]): The name of the modules.
        &#34;&#34;&#34;
        self.hl_solver = hl_solver
        self.ll_solver = ll_solver
        self.check_sat = True
        self.modules = [LSystemModule(hl_solver=hl_solver,
                                      ll_solver=ll_solver,
                                      name=name) for name in names]
        # Default behavior for user study spaceships (temporary)
        for module in self.modules:
            if &#39;head&#39; in module.name.lower() or &#39;tail&#39; in module.name.lower():
                module.active = False
        
        self.all_hl_constraints = set()
        self.all_ll_constraints = set()

    def enable_sat_check(self):
        &#34;&#34;&#34;Enable constraints satisfaction&#34;&#34;&#34;
        self.check_sat = True
        for m in self.modules:
            m.check_sat = True

    def disable_sat_check(self):
        &#34;&#34;&#34;Disable constraints satisfaction&#34;&#34;&#34;
        self.check_sat = False
        for m in self.modules:
            m.check_sat = False

    def add_hl_constraints(self,
                           cs: List[List[Optional[ConstraintHandler]]]) -&gt; None:
        &#34;&#34;&#34;Add high-level constraints to each module.

        Args:
            cs (List[List[Optional[ConstraintHandler]]]): The list of constraints.
        &#34;&#34;&#34;
        assert len(cs) == len(self.modules), f&#39;Wrong number of expected modules: have {len(self.modules)}, passed {len(cs)}.&#39;
        for m, mcs in zip(self.modules, cs):
            for c in mcs:
                m.add_hl_constraint(c)
                self.all_hl_constraints.add(c)

    def add_ll_constraints(self,
                           cs: List[List[Optional[ConstraintHandler]]]) -&gt; None:
        &#34;&#34;&#34;Add low-level constraints to each module.

        Args:
            cs (List[List[Optional[ConstraintHandler]]]): The list of constraints.
        &#34;&#34;&#34;
        assert len(cs) == len(self.modules), f&#39;Wrong number of expected modules: have {len(self.modules)}, passed {len(cs)}.&#39;
        for m, mcs in zip(self.modules, cs):
            for c in mcs:
                m.add_ll_constraint(c)
                self.all_ll_constraints.add(c)

    def process_module(self,
                       module: LSystemModule,
                       starting_string: str,
                       iterations: int = 1) -&gt; List[CandidateSolution]:
        &#34;&#34;&#34;Process the given module, applying the expansion rules.

        Args:
            module (LSystemModule): The module.
            starting_string (str): The starting string.
            iterations (int, optional): The number of iterations to expand for. Defaults to 1.

        Returns:
            List[CandidateSolution]: The list of solutions.
        &#34;&#34;&#34;
        return module.apply_rules(starting_string=starting_string,
                                  iterations=iterations)

    def _produce_solutions_combinations(self,
                                        lcs: List[CandidateSolution]) -&gt; List[CandidateSolution]:
        &#34;&#34;&#34;Produce the combination of solutions&#39; strings.

        Args:
            lcs (List[CandidateSolution]): The list of solutions.

        Returns:
            List[CandidateSolution]: The list of solutions.
        &#34;&#34;&#34;
        # Cartesian product of all strings, return merged string
        return [merge_solutions(lcs=x, modules_names=[m.name for m in self.modules], modules_active=[m.active for m in self.modules]) for x in list(itertools.product(*lcs))]

    def _add_ll_strings(self,
                        cs: CandidateSolution) -&gt; CandidateSolution:
        &#34;&#34;&#34;Add the low-level string to a solution.

        Args:
            cs (CandidateSolution): The solution.

        Returns:
            CandidateSolution: The solution with the low-level string set.
        &#34;&#34;&#34;
        ml_string = self.hl_solver.translator.transform(string=cs.string)
        cs.ll_string = self.ll_solver.solve(string=ml_string,
                                            iterations=1,
                                            strings_per_iteration=1,
                                            check_sat=False)[0].string
        return cs

    def _set_structure(self,
                       cs: CandidateSolution,
                       make_graph: bool = False) -&gt; CandidateSolution:
        &#34;&#34;&#34;Set the structure of the solution.

        Args:
            cs (CandidateSolution): The solution
            make_graph (bool, optional): Whether to plot the structure. Defaults to False.

        Returns:
            CandidateSolution: The solution with the structure set
        &#34;&#34;&#34;
        base_position, orientation_forward, orientation_up = Vec.v3i(0, 0, 0), Orientation.FORWARD.value, Orientation.UP.value
        structure = Structure(origin=base_position,
                              orientation_forward=orientation_forward,
                              orientation_up=orientation_up)
        structure = LLStructureMaker(atoms_alphabet=self.ll_solver.atoms_alphabet,
                                     position=base_position).fill_structure(structure=structure,
                                                                            string=cs.ll_string)

        cs.set_content(content=structure)
        if make_graph:
            structure.show(title=cs.string)
        return cs

    def apply_rules(self,
                    starting_strings: List[str],
                    iterations: List[int],
                    create_structures: bool = False,
                    make_graph: bool = False) -&gt; List[CandidateSolution]:
        &#34;&#34;&#34;Apply the expansion rules for the hierarchical L-system.

        Args:
            starting_strings (List[str]): The starting strings (one per module).
            iterations (List[int]): The number of iterations to expand for (one per module).
            create_structures (bool, optional): Whether to create structures for each solution. Defaults to False.
            make_graph (bool, optional): Whether to plot the structure. Defaults to False.

        Returns:
            List[CandidateSolution]: The list of solutions.
        &#34;&#34;&#34;
        assert len(starting_strings) == len(self.modules), f&#39;Assumed wrong number of modules: have {len(self.modules)}, passed {len(starting_strings)}.&#39;
        assert len(iterations) == len(self.modules), f&#39;Assumed wrong number of modules: have {len(self.modules)}, passed {len(iterations)}.&#39;
        # create solutions for each module and combine them
        solutions = self._produce_solutions_combinations([self.process_module(module=module,
                                                                              starting_string=starting_string,
                                                                              iterations=n_iterations) for module, starting_string, n_iterations in zip(self.modules, starting_strings, iterations)])
        # set low-level strings
        solutions = list(map(lambda cs: self._add_ll_strings(cs=cs), solutions))
        # if enabled, create the structures
        if create_structures:
            solutions = list(map(lambda cs: self._set_structure(cs=cs, make_graph=make_graph), solutions))
        return solutions

    def to_json(self) -&gt; Dict[str, Any]:
        return {
            &#39;hlsolver&#39;: self.hl_solver.to_json(),
            &#39;llsolver&#39;: self.ll_solver.to_json(),
            &#39;check_sat&#39;: self.check_sat,
            &#39;modules&#39;: [m.to_json() for m in self.modules],
            &#39;all_hl_constraints&#39;: [c.to_json() for c in self.all_hl_constraints],
            &#39;all_ll_constraints&#39;: [c.to_json() for c in self.all_ll_constraints]
        }

    @staticmethod
    def from_json(my_args: Dict[str, Any]) -&gt; &#39;LSystem&#39;:
        ls = LSystem(hl_solver=LSolver.from_json(my_args[&#39;hlsolver&#39;]),
                     ll_solver=LSolver.from_json(my_args[&#39;llsolver&#39;]),
                     names=[])
        ls.modules = [LSystemModule.from_json(lsm) for lsm in my_args[&#39;modules&#39;]]
        ls.all_hl_constraints = set([ConstraintHandler.from_json(c) for c in my_args[&#39;all_hl_constraints&#39;]])
        ls.all_ll_constraints = set([ConstraintHandler.from_json(c) for c in my_args[&#39;all_ll_constraints&#39;]])
        return ls</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pcgsepy.lsystem.lsystem.LSystem"><code class="flex name class">
<span>class <span class="ident">LSystem</span></span>
<span>(</span><span>hl_solver: <a title="pcgsepy.lsystem.solver.LSolver" href="solver.html#pcgsepy.lsystem.solver.LSolver">LSolver</a>, ll_solver: <a title="pcgsepy.lsystem.solver.LSolver" href="solver.html#pcgsepy.lsystem.solver.LSolver">LSolver</a>, names: List[str])</span>
</code></dt>
<dd>
<div class="desc"><p>Create the hierarchical L-system. Each name corresponds to a L-system sub-module.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>hl_solver</code></strong> :&ensp;<code>LSolver</code></dt>
<dd>The high-level solver.</dd>
<dt><strong><code>ll_solver</code></strong> :&ensp;<code>LSolver</code></dt>
<dd>The low-level solver.</dd>
<dt><strong><code>names</code></strong> :&ensp;<code>List[str]</code></dt>
<dd>The name of the modules.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LSystem:
    def __init__(self,
                 hl_solver: LSolver,
                 ll_solver: LSolver,
                 names: List[str]):
        &#34;&#34;&#34;Create the hierarchical L-system. Each name corresponds to a L-system sub-module.

        Args:
            hl_solver (LSolver): The high-level solver.
            ll_solver (LSolver): The low-level solver.
            names (List[str]): The name of the modules.
        &#34;&#34;&#34;
        self.hl_solver = hl_solver
        self.ll_solver = ll_solver
        self.check_sat = True
        self.modules = [LSystemModule(hl_solver=hl_solver,
                                      ll_solver=ll_solver,
                                      name=name) for name in names]
        # Default behavior for user study spaceships (temporary)
        for module in self.modules:
            if &#39;head&#39; in module.name.lower() or &#39;tail&#39; in module.name.lower():
                module.active = False
        
        self.all_hl_constraints = set()
        self.all_ll_constraints = set()

    def enable_sat_check(self):
        &#34;&#34;&#34;Enable constraints satisfaction&#34;&#34;&#34;
        self.check_sat = True
        for m in self.modules:
            m.check_sat = True

    def disable_sat_check(self):
        &#34;&#34;&#34;Disable constraints satisfaction&#34;&#34;&#34;
        self.check_sat = False
        for m in self.modules:
            m.check_sat = False

    def add_hl_constraints(self,
                           cs: List[List[Optional[ConstraintHandler]]]) -&gt; None:
        &#34;&#34;&#34;Add high-level constraints to each module.

        Args:
            cs (List[List[Optional[ConstraintHandler]]]): The list of constraints.
        &#34;&#34;&#34;
        assert len(cs) == len(self.modules), f&#39;Wrong number of expected modules: have {len(self.modules)}, passed {len(cs)}.&#39;
        for m, mcs in zip(self.modules, cs):
            for c in mcs:
                m.add_hl_constraint(c)
                self.all_hl_constraints.add(c)

    def add_ll_constraints(self,
                           cs: List[List[Optional[ConstraintHandler]]]) -&gt; None:
        &#34;&#34;&#34;Add low-level constraints to each module.

        Args:
            cs (List[List[Optional[ConstraintHandler]]]): The list of constraints.
        &#34;&#34;&#34;
        assert len(cs) == len(self.modules), f&#39;Wrong number of expected modules: have {len(self.modules)}, passed {len(cs)}.&#39;
        for m, mcs in zip(self.modules, cs):
            for c in mcs:
                m.add_ll_constraint(c)
                self.all_ll_constraints.add(c)

    def process_module(self,
                       module: LSystemModule,
                       starting_string: str,
                       iterations: int = 1) -&gt; List[CandidateSolution]:
        &#34;&#34;&#34;Process the given module, applying the expansion rules.

        Args:
            module (LSystemModule): The module.
            starting_string (str): The starting string.
            iterations (int, optional): The number of iterations to expand for. Defaults to 1.

        Returns:
            List[CandidateSolution]: The list of solutions.
        &#34;&#34;&#34;
        return module.apply_rules(starting_string=starting_string,
                                  iterations=iterations)

    def _produce_solutions_combinations(self,
                                        lcs: List[CandidateSolution]) -&gt; List[CandidateSolution]:
        &#34;&#34;&#34;Produce the combination of solutions&#39; strings.

        Args:
            lcs (List[CandidateSolution]): The list of solutions.

        Returns:
            List[CandidateSolution]: The list of solutions.
        &#34;&#34;&#34;
        # Cartesian product of all strings, return merged string
        return [merge_solutions(lcs=x, modules_names=[m.name for m in self.modules], modules_active=[m.active for m in self.modules]) for x in list(itertools.product(*lcs))]

    def _add_ll_strings(self,
                        cs: CandidateSolution) -&gt; CandidateSolution:
        &#34;&#34;&#34;Add the low-level string to a solution.

        Args:
            cs (CandidateSolution): The solution.

        Returns:
            CandidateSolution: The solution with the low-level string set.
        &#34;&#34;&#34;
        ml_string = self.hl_solver.translator.transform(string=cs.string)
        cs.ll_string = self.ll_solver.solve(string=ml_string,
                                            iterations=1,
                                            strings_per_iteration=1,
                                            check_sat=False)[0].string
        return cs

    def _set_structure(self,
                       cs: CandidateSolution,
                       make_graph: bool = False) -&gt; CandidateSolution:
        &#34;&#34;&#34;Set the structure of the solution.

        Args:
            cs (CandidateSolution): The solution
            make_graph (bool, optional): Whether to plot the structure. Defaults to False.

        Returns:
            CandidateSolution: The solution with the structure set
        &#34;&#34;&#34;
        base_position, orientation_forward, orientation_up = Vec.v3i(0, 0, 0), Orientation.FORWARD.value, Orientation.UP.value
        structure = Structure(origin=base_position,
                              orientation_forward=orientation_forward,
                              orientation_up=orientation_up)
        structure = LLStructureMaker(atoms_alphabet=self.ll_solver.atoms_alphabet,
                                     position=base_position).fill_structure(structure=structure,
                                                                            string=cs.ll_string)

        cs.set_content(content=structure)
        if make_graph:
            structure.show(title=cs.string)
        return cs

    def apply_rules(self,
                    starting_strings: List[str],
                    iterations: List[int],
                    create_structures: bool = False,
                    make_graph: bool = False) -&gt; List[CandidateSolution]:
        &#34;&#34;&#34;Apply the expansion rules for the hierarchical L-system.

        Args:
            starting_strings (List[str]): The starting strings (one per module).
            iterations (List[int]): The number of iterations to expand for (one per module).
            create_structures (bool, optional): Whether to create structures for each solution. Defaults to False.
            make_graph (bool, optional): Whether to plot the structure. Defaults to False.

        Returns:
            List[CandidateSolution]: The list of solutions.
        &#34;&#34;&#34;
        assert len(starting_strings) == len(self.modules), f&#39;Assumed wrong number of modules: have {len(self.modules)}, passed {len(starting_strings)}.&#39;
        assert len(iterations) == len(self.modules), f&#39;Assumed wrong number of modules: have {len(self.modules)}, passed {len(iterations)}.&#39;
        # create solutions for each module and combine them
        solutions = self._produce_solutions_combinations([self.process_module(module=module,
                                                                              starting_string=starting_string,
                                                                              iterations=n_iterations) for module, starting_string, n_iterations in zip(self.modules, starting_strings, iterations)])
        # set low-level strings
        solutions = list(map(lambda cs: self._add_ll_strings(cs=cs), solutions))
        # if enabled, create the structures
        if create_structures:
            solutions = list(map(lambda cs: self._set_structure(cs=cs, make_graph=make_graph), solutions))
        return solutions

    def to_json(self) -&gt; Dict[str, Any]:
        return {
            &#39;hlsolver&#39;: self.hl_solver.to_json(),
            &#39;llsolver&#39;: self.ll_solver.to_json(),
            &#39;check_sat&#39;: self.check_sat,
            &#39;modules&#39;: [m.to_json() for m in self.modules],
            &#39;all_hl_constraints&#39;: [c.to_json() for c in self.all_hl_constraints],
            &#39;all_ll_constraints&#39;: [c.to_json() for c in self.all_ll_constraints]
        }

    @staticmethod
    def from_json(my_args: Dict[str, Any]) -&gt; &#39;LSystem&#39;:
        ls = LSystem(hl_solver=LSolver.from_json(my_args[&#39;hlsolver&#39;]),
                     ll_solver=LSolver.from_json(my_args[&#39;llsolver&#39;]),
                     names=[])
        ls.modules = [LSystemModule.from_json(lsm) for lsm in my_args[&#39;modules&#39;]]
        ls.all_hl_constraints = set([ConstraintHandler.from_json(c) for c in my_args[&#39;all_hl_constraints&#39;]])
        ls.all_ll_constraints = set([ConstraintHandler.from_json(c) for c in my_args[&#39;all_ll_constraints&#39;]])
        return ls</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="pcgsepy.lsystem.lsystem.LSystem.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>my_args: Dict[str, Any]) ‑> <a title="pcgsepy.lsystem.lsystem.LSystem" href="#pcgsepy.lsystem.lsystem.LSystem">LSystem</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_json(my_args: Dict[str, Any]) -&gt; &#39;LSystem&#39;:
    ls = LSystem(hl_solver=LSolver.from_json(my_args[&#39;hlsolver&#39;]),
                 ll_solver=LSolver.from_json(my_args[&#39;llsolver&#39;]),
                 names=[])
    ls.modules = [LSystemModule.from_json(lsm) for lsm in my_args[&#39;modules&#39;]]
    ls.all_hl_constraints = set([ConstraintHandler.from_json(c) for c in my_args[&#39;all_hl_constraints&#39;]])
    ls.all_ll_constraints = set([ConstraintHandler.from_json(c) for c in my_args[&#39;all_ll_constraints&#39;]])
    return ls</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pcgsepy.lsystem.lsystem.LSystem.add_hl_constraints"><code class="name flex">
<span>def <span class="ident">add_hl_constraints</span></span>(<span>self, cs: List[List[Optional[<a title="pcgsepy.lsystem.constraints.ConstraintHandler" href="constraints.html#pcgsepy.lsystem.constraints.ConstraintHandler">ConstraintHandler</a>]]]) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Add high-level constraints to each module.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cs</code></strong> :&ensp;<code>List[List[Optional[ConstraintHandler]]]</code></dt>
<dd>The list of constraints.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_hl_constraints(self,
                       cs: List[List[Optional[ConstraintHandler]]]) -&gt; None:
    &#34;&#34;&#34;Add high-level constraints to each module.

    Args:
        cs (List[List[Optional[ConstraintHandler]]]): The list of constraints.
    &#34;&#34;&#34;
    assert len(cs) == len(self.modules), f&#39;Wrong number of expected modules: have {len(self.modules)}, passed {len(cs)}.&#39;
    for m, mcs in zip(self.modules, cs):
        for c in mcs:
            m.add_hl_constraint(c)
            self.all_hl_constraints.add(c)</code></pre>
</details>
</dd>
<dt id="pcgsepy.lsystem.lsystem.LSystem.add_ll_constraints"><code class="name flex">
<span>def <span class="ident">add_ll_constraints</span></span>(<span>self, cs: List[List[Optional[<a title="pcgsepy.lsystem.constraints.ConstraintHandler" href="constraints.html#pcgsepy.lsystem.constraints.ConstraintHandler">ConstraintHandler</a>]]]) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Add low-level constraints to each module.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>cs</code></strong> :&ensp;<code>List[List[Optional[ConstraintHandler]]]</code></dt>
<dd>The list of constraints.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_ll_constraints(self,
                       cs: List[List[Optional[ConstraintHandler]]]) -&gt; None:
    &#34;&#34;&#34;Add low-level constraints to each module.

    Args:
        cs (List[List[Optional[ConstraintHandler]]]): The list of constraints.
    &#34;&#34;&#34;
    assert len(cs) == len(self.modules), f&#39;Wrong number of expected modules: have {len(self.modules)}, passed {len(cs)}.&#39;
    for m, mcs in zip(self.modules, cs):
        for c in mcs:
            m.add_ll_constraint(c)
            self.all_ll_constraints.add(c)</code></pre>
</details>
</dd>
<dt id="pcgsepy.lsystem.lsystem.LSystem.apply_rules"><code class="name flex">
<span>def <span class="ident">apply_rules</span></span>(<span>self, starting_strings: List[str], iterations: List[int], create_structures: bool = False, make_graph: bool = False) ‑> List[<a title="pcgsepy.lsystem.solution.CandidateSolution" href="solution.html#pcgsepy.lsystem.solution.CandidateSolution">CandidateSolution</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Apply the expansion rules for the hierarchical L-system.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>starting_strings</code></strong> :&ensp;<code>List[str]</code></dt>
<dd>The starting strings (one per module).</dd>
<dt><strong><code>iterations</code></strong> :&ensp;<code>List[int]</code></dt>
<dd>The number of iterations to expand for (one per module).</dd>
<dt><strong><code>create_structures</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to create structures for each solution. Defaults to False.</dd>
<dt><strong><code>make_graph</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to plot the structure. Defaults to False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List[CandidateSolution]</code></dt>
<dd>The list of solutions.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply_rules(self,
                starting_strings: List[str],
                iterations: List[int],
                create_structures: bool = False,
                make_graph: bool = False) -&gt; List[CandidateSolution]:
    &#34;&#34;&#34;Apply the expansion rules for the hierarchical L-system.

    Args:
        starting_strings (List[str]): The starting strings (one per module).
        iterations (List[int]): The number of iterations to expand for (one per module).
        create_structures (bool, optional): Whether to create structures for each solution. Defaults to False.
        make_graph (bool, optional): Whether to plot the structure. Defaults to False.

    Returns:
        List[CandidateSolution]: The list of solutions.
    &#34;&#34;&#34;
    assert len(starting_strings) == len(self.modules), f&#39;Assumed wrong number of modules: have {len(self.modules)}, passed {len(starting_strings)}.&#39;
    assert len(iterations) == len(self.modules), f&#39;Assumed wrong number of modules: have {len(self.modules)}, passed {len(iterations)}.&#39;
    # create solutions for each module and combine them
    solutions = self._produce_solutions_combinations([self.process_module(module=module,
                                                                          starting_string=starting_string,
                                                                          iterations=n_iterations) for module, starting_string, n_iterations in zip(self.modules, starting_strings, iterations)])
    # set low-level strings
    solutions = list(map(lambda cs: self._add_ll_strings(cs=cs), solutions))
    # if enabled, create the structures
    if create_structures:
        solutions = list(map(lambda cs: self._set_structure(cs=cs, make_graph=make_graph), solutions))
    return solutions</code></pre>
</details>
</dd>
<dt id="pcgsepy.lsystem.lsystem.LSystem.disable_sat_check"><code class="name flex">
<span>def <span class="ident">disable_sat_check</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Disable constraints satisfaction</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disable_sat_check(self):
    &#34;&#34;&#34;Disable constraints satisfaction&#34;&#34;&#34;
    self.check_sat = False
    for m in self.modules:
        m.check_sat = False</code></pre>
</details>
</dd>
<dt id="pcgsepy.lsystem.lsystem.LSystem.enable_sat_check"><code class="name flex">
<span>def <span class="ident">enable_sat_check</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Enable constraints satisfaction</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def enable_sat_check(self):
    &#34;&#34;&#34;Enable constraints satisfaction&#34;&#34;&#34;
    self.check_sat = True
    for m in self.modules:
        m.check_sat = True</code></pre>
</details>
</dd>
<dt id="pcgsepy.lsystem.lsystem.LSystem.process_module"><code class="name flex">
<span>def <span class="ident">process_module</span></span>(<span>self, module: <a title="pcgsepy.lsystem.lsystem.LSystemModule" href="#pcgsepy.lsystem.lsystem.LSystemModule">LSystemModule</a>, starting_string: str, iterations: int = 1) ‑> List[<a title="pcgsepy.lsystem.solution.CandidateSolution" href="solution.html#pcgsepy.lsystem.solution.CandidateSolution">CandidateSolution</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Process the given module, applying the expansion rules.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>module</code></strong> :&ensp;<code><a title="pcgsepy.lsystem.lsystem.LSystemModule" href="#pcgsepy.lsystem.lsystem.LSystemModule">LSystemModule</a></code></dt>
<dd>The module.</dd>
<dt><strong><code>starting_string</code></strong> :&ensp;<code>str</code></dt>
<dd>The starting string.</dd>
<dt><strong><code>iterations</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The number of iterations to expand for. Defaults to 1.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List[CandidateSolution]</code></dt>
<dd>The list of solutions.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def process_module(self,
                   module: LSystemModule,
                   starting_string: str,
                   iterations: int = 1) -&gt; List[CandidateSolution]:
    &#34;&#34;&#34;Process the given module, applying the expansion rules.

    Args:
        module (LSystemModule): The module.
        starting_string (str): The starting string.
        iterations (int, optional): The number of iterations to expand for. Defaults to 1.

    Returns:
        List[CandidateSolution]: The list of solutions.
    &#34;&#34;&#34;
    return module.apply_rules(starting_string=starting_string,
                              iterations=iterations)</code></pre>
</details>
</dd>
<dt id="pcgsepy.lsystem.lsystem.LSystem.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self) ‑> Dict[str, Any]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self) -&gt; Dict[str, Any]:
    return {
        &#39;hlsolver&#39;: self.hl_solver.to_json(),
        &#39;llsolver&#39;: self.ll_solver.to_json(),
        &#39;check_sat&#39;: self.check_sat,
        &#39;modules&#39;: [m.to_json() for m in self.modules],
        &#39;all_hl_constraints&#39;: [c.to_json() for c in self.all_hl_constraints],
        &#39;all_ll_constraints&#39;: [c.to_json() for c in self.all_ll_constraints]
    }</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="pcgsepy.lsystem.lsystem.LSystemModule"><code class="flex name class">
<span>class <span class="ident">LSystemModule</span></span>
<span>(</span><span>hl_solver: <a title="pcgsepy.lsystem.solver.LSolver" href="solver.html#pcgsepy.lsystem.solver.LSolver">LSolver</a>, ll_solver: <a title="pcgsepy.lsystem.solver.LSolver" href="solver.html#pcgsepy.lsystem.solver.LSolver">LSolver</a>, name: str)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a module of the hierarchical L-system.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>hl_solver</code></strong> :&ensp;<code>LSolver</code></dt>
<dd>The high-level solver.</dd>
<dt><strong><code>ll_solver</code></strong> :&ensp;<code>LSolver</code></dt>
<dd>The low-level solver.</dd>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the module.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class LSystemModule:
    __slots__ = [&#39;hlsolver&#39;, &#39;llsolver&#39;, &#39;check_sat&#39;,
                 &#39;name&#39;, &#39;active&#39;, &#39;hl_constraints&#39;, &#39;ll_constraints&#39;]

    def __init__(self,
                 hl_solver: LSolver,
                 ll_solver: LSolver,
                 name: str):
        &#34;&#34;&#34;Create a module of the hierarchical L-system.

        Args:
            hl_solver (LSolver): The high-level solver.
            ll_solver (LSolver): The low-level solver.
            name (str): The name of the module.
        &#34;&#34;&#34;
        self.hlsolver = hl_solver
        self.llsolver = ll_solver
        self.check_sat = True
        self.name = name
        self.active = True
        self.hl_constraints = []
        self.ll_constraints = []

    def add_hl_constraint(self,
                          c: ConstraintHandler) -&gt; None:
        &#34;&#34;&#34;Add a high-level constraint to the module.

        Args:
            c (ConstraintHandler): The constraint.
        &#34;&#34;&#34;
        self.hl_constraints.append(c)

    def add_ll_constraint(self,
                          c: ConstraintHandler) -&gt; None:
        &#34;&#34;&#34;Add a low-level constraint to the module.

        Args:
            c (ConstraintHandler): The constraint.
        &#34;&#34;&#34;
        self.ll_constraints.append(c)

    def _get_hl_solutions(self,
                          starting_string: str,
                          iterations: int = 1) -&gt; List[CandidateSolution]:
        &#34;&#34;&#34;Get the high-level solutions.

        Args:
            starting_string (str): The starting string.
            iterations (int, optional): The number of iterations to expand for. Defaults to 1.

        Returns:
            List[CandidateSolution]: The list of solutions.
        &#34;&#34;&#34;
        return self.hlsolver.solve(string=starting_string,
                                   iterations=iterations,
                                   strings_per_iteration=N_SPE,
                                   check_sat=self.check_sat)

    def _get_ml_strings(self,
                        hl_strings: List[str]) -&gt; List[str]:
        &#34;&#34;&#34;Convert the high-level strings to mid-level.

        Args:
            hl_strings (List[str]): The high-level strings.

        Returns:
            List[str]: The list of mid-level strings.
        &#34;&#34;&#34;
        return [self.hlsolver.translator.transform(string=hl_string) for hl_string in hl_strings]

    def _get_ll_solutions(self,
                          cs: List[CandidateSolution]) -&gt; Tuple[List[CandidateSolution], npt.NDArray[np.bool8]]:
        &#34;&#34;&#34;Get the low-level solutions.
        Make sure that each high-level solutions already has a mid-level string assigned.

        Args:
            cs (List[CandidateSolution]): The list of high-level solutions.

        Returns:
            Tuple[List[CandidateSolution], npt.NDArray[np.bool8]]: The list of solutions and which solutions should be kept.
        &#34;&#34;&#34;
        ll_solutions, to_keep = [], np.zeros(shape=len(cs), dtype=np.bool8)
        for i, cs in enumerate(cs):
            ll_solution = self.llsolver.solve(string=cs.string,
                                              iterations=1,
                                              strings_per_iteration=1,
                                              check_sat=self.check_sat)[0]
            if ll_solution:
                ll_solutions.append(ll_solution)
                to_keep[i] = True
        return ll_solutions, to_keep

    def apply_rules(self,
                    starting_string: str,
                    iterations: int = 1) -&gt; List[CandidateSolution]:
        &#34;&#34;&#34;Apply the rules of the module to a given starting string.

        Args:
            starting_string (str): The starting string.
            iterations (int, optional): The number of iterations to expand for. Defaults to 1.

        Returns:
            List[CandidateSolution]: The list of solutions.
        &#34;&#34;&#34;
        self.hlsolver.set_constraints(cs=self.hl_constraints)
        self.llsolver.set_constraints(cs=self.ll_constraints)
        logging.getLogger(&#39;base-logger&#39;).info(f&#39;[{self.name}] Started high level solving...&#39;)
        hl_solutions = self._get_hl_solutions(starting_string=starting_string,
                                              iterations=iterations)
        logging.getLogger(&#39;base-logger&#39;).debug(f&#39;[{self.name}] Converting HL strings to ML...&#39;)
        ml_strings = self._get_ml_strings([cs.string for cs in hl_solutions])
        logging.getLogger(&#39;base-logger&#39;).info(f&#39;[{self.name}] Started low level solving...&#39;)
        _, to_keep = self._get_ll_solutions([CandidateSolution(string=s,
                                                               content=hl_cs._content) for s, hl_cs in zip(ml_strings, hl_solutions)])
        hl_solutions = [x for x, k in zip(hl_solutions, to_keep) if k]
        return hl_solutions

    def to_json(self) -&gt; Dict[str, Any]:
        return {
            &#39;hlsolver&#39;: self.hlsolver.to_json(),
            &#39;llsolver&#39;: self.llsolver.to_json(),
            &#39;check_sat&#39;: self.check_sat,
            &#39;name&#39;: self.name,
            &#39;active&#39;: self.active,
            &#39;hl_constraints&#39;: [c.to_json() for c in self.hl_constraints],
            &#39;ll_constraints&#39;: [c.to_json() for c in self.ll_constraints],
        }

    @staticmethod
    def from_json(my_args: Dict[str, Any]) -&gt; &#39;LSystemModule&#39;:
        lsm = LSystemModule(hl_solver=LSolver.from_json(my_args[&#39;hlsolver&#39;]),
                            ll_solver=LSolver.from_json(my_args[&#39;llsolver&#39;]),
                            name=my_args[&#39;name&#39;])
        lsm.active = my_args[&#39;active&#39;]
        lsm.hl_constraints = [ConstraintHandler.from_json(c) for c in my_args[&#39;hl_constraints&#39;]]
        lsm.ll_constraints = [ConstraintHandler.from_json(c) for c in my_args[&#39;ll_constraints&#39;]]
        return lsm</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="pcgsepy.lsystem.lsystem.LSystemModule.from_json"><code class="name flex">
<span>def <span class="ident">from_json</span></span>(<span>my_args: Dict[str, Any]) ‑> <a title="pcgsepy.lsystem.lsystem.LSystemModule" href="#pcgsepy.lsystem.lsystem.LSystemModule">LSystemModule</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def from_json(my_args: Dict[str, Any]) -&gt; &#39;LSystemModule&#39;:
    lsm = LSystemModule(hl_solver=LSolver.from_json(my_args[&#39;hlsolver&#39;]),
                        ll_solver=LSolver.from_json(my_args[&#39;llsolver&#39;]),
                        name=my_args[&#39;name&#39;])
    lsm.active = my_args[&#39;active&#39;]
    lsm.hl_constraints = [ConstraintHandler.from_json(c) for c in my_args[&#39;hl_constraints&#39;]]
    lsm.ll_constraints = [ConstraintHandler.from_json(c) for c in my_args[&#39;ll_constraints&#39;]]
    return lsm</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="pcgsepy.lsystem.lsystem.LSystemModule.active"><code class="name">var <span class="ident">active</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="pcgsepy.lsystem.lsystem.LSystemModule.check_sat"><code class="name">var <span class="ident">check_sat</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="pcgsepy.lsystem.lsystem.LSystemModule.hl_constraints"><code class="name">var <span class="ident">hl_constraints</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="pcgsepy.lsystem.lsystem.LSystemModule.hlsolver"><code class="name">var <span class="ident">hlsolver</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="pcgsepy.lsystem.lsystem.LSystemModule.ll_constraints"><code class="name">var <span class="ident">ll_constraints</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="pcgsepy.lsystem.lsystem.LSystemModule.llsolver"><code class="name">var <span class="ident">llsolver</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
<dt id="pcgsepy.lsystem.lsystem.LSystemModule.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><p>Return an attribute of instance, which is of type owner.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pcgsepy.lsystem.lsystem.LSystemModule.add_hl_constraint"><code class="name flex">
<span>def <span class="ident">add_hl_constraint</span></span>(<span>self, c: <a title="pcgsepy.lsystem.constraints.ConstraintHandler" href="constraints.html#pcgsepy.lsystem.constraints.ConstraintHandler">ConstraintHandler</a>) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Add a high-level constraint to the module.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>c</code></strong> :&ensp;<code>ConstraintHandler</code></dt>
<dd>The constraint.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_hl_constraint(self,
                      c: ConstraintHandler) -&gt; None:
    &#34;&#34;&#34;Add a high-level constraint to the module.

    Args:
        c (ConstraintHandler): The constraint.
    &#34;&#34;&#34;
    self.hl_constraints.append(c)</code></pre>
</details>
</dd>
<dt id="pcgsepy.lsystem.lsystem.LSystemModule.add_ll_constraint"><code class="name flex">
<span>def <span class="ident">add_ll_constraint</span></span>(<span>self, c: <a title="pcgsepy.lsystem.constraints.ConstraintHandler" href="constraints.html#pcgsepy.lsystem.constraints.ConstraintHandler">ConstraintHandler</a>) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Add a low-level constraint to the module.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>c</code></strong> :&ensp;<code>ConstraintHandler</code></dt>
<dd>The constraint.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_ll_constraint(self,
                      c: ConstraintHandler) -&gt; None:
    &#34;&#34;&#34;Add a low-level constraint to the module.

    Args:
        c (ConstraintHandler): The constraint.
    &#34;&#34;&#34;
    self.ll_constraints.append(c)</code></pre>
</details>
</dd>
<dt id="pcgsepy.lsystem.lsystem.LSystemModule.apply_rules"><code class="name flex">
<span>def <span class="ident">apply_rules</span></span>(<span>self, starting_string: str, iterations: int = 1) ‑> List[<a title="pcgsepy.lsystem.solution.CandidateSolution" href="solution.html#pcgsepy.lsystem.solution.CandidateSolution">CandidateSolution</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Apply the rules of the module to a given starting string.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>starting_string</code></strong> :&ensp;<code>str</code></dt>
<dd>The starting string.</dd>
<dt><strong><code>iterations</code></strong> :&ensp;<code>int</code>, optional</dt>
<dd>The number of iterations to expand for. Defaults to 1.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>List[CandidateSolution]</code></dt>
<dd>The list of solutions.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def apply_rules(self,
                starting_string: str,
                iterations: int = 1) -&gt; List[CandidateSolution]:
    &#34;&#34;&#34;Apply the rules of the module to a given starting string.

    Args:
        starting_string (str): The starting string.
        iterations (int, optional): The number of iterations to expand for. Defaults to 1.

    Returns:
        List[CandidateSolution]: The list of solutions.
    &#34;&#34;&#34;
    self.hlsolver.set_constraints(cs=self.hl_constraints)
    self.llsolver.set_constraints(cs=self.ll_constraints)
    logging.getLogger(&#39;base-logger&#39;).info(f&#39;[{self.name}] Started high level solving...&#39;)
    hl_solutions = self._get_hl_solutions(starting_string=starting_string,
                                          iterations=iterations)
    logging.getLogger(&#39;base-logger&#39;).debug(f&#39;[{self.name}] Converting HL strings to ML...&#39;)
    ml_strings = self._get_ml_strings([cs.string for cs in hl_solutions])
    logging.getLogger(&#39;base-logger&#39;).info(f&#39;[{self.name}] Started low level solving...&#39;)
    _, to_keep = self._get_ll_solutions([CandidateSolution(string=s,
                                                           content=hl_cs._content) for s, hl_cs in zip(ml_strings, hl_solutions)])
    hl_solutions = [x for x, k in zip(hl_solutions, to_keep) if k]
    return hl_solutions</code></pre>
</details>
</dd>
<dt id="pcgsepy.lsystem.lsystem.LSystemModule.to_json"><code class="name flex">
<span>def <span class="ident">to_json</span></span>(<span>self) ‑> Dict[str, Any]</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_json(self) -&gt; Dict[str, Any]:
    return {
        &#39;hlsolver&#39;: self.hlsolver.to_json(),
        &#39;llsolver&#39;: self.llsolver.to_json(),
        &#39;check_sat&#39;: self.check_sat,
        &#39;name&#39;: self.name,
        &#39;active&#39;: self.active,
        &#39;hl_constraints&#39;: [c.to_json() for c in self.hl_constraints],
        &#39;ll_constraints&#39;: [c.to_json() for c in self.ll_constraints],
    }</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="pcgsepy.lsystem" href="index.html">pcgsepy.lsystem</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pcgsepy.lsystem.lsystem.LSystem" href="#pcgsepy.lsystem.lsystem.LSystem">LSystem</a></code></h4>
<ul class="two-column">
<li><code><a title="pcgsepy.lsystem.lsystem.LSystem.add_hl_constraints" href="#pcgsepy.lsystem.lsystem.LSystem.add_hl_constraints">add_hl_constraints</a></code></li>
<li><code><a title="pcgsepy.lsystem.lsystem.LSystem.add_ll_constraints" href="#pcgsepy.lsystem.lsystem.LSystem.add_ll_constraints">add_ll_constraints</a></code></li>
<li><code><a title="pcgsepy.lsystem.lsystem.LSystem.apply_rules" href="#pcgsepy.lsystem.lsystem.LSystem.apply_rules">apply_rules</a></code></li>
<li><code><a title="pcgsepy.lsystem.lsystem.LSystem.disable_sat_check" href="#pcgsepy.lsystem.lsystem.LSystem.disable_sat_check">disable_sat_check</a></code></li>
<li><code><a title="pcgsepy.lsystem.lsystem.LSystem.enable_sat_check" href="#pcgsepy.lsystem.lsystem.LSystem.enable_sat_check">enable_sat_check</a></code></li>
<li><code><a title="pcgsepy.lsystem.lsystem.LSystem.from_json" href="#pcgsepy.lsystem.lsystem.LSystem.from_json">from_json</a></code></li>
<li><code><a title="pcgsepy.lsystem.lsystem.LSystem.process_module" href="#pcgsepy.lsystem.lsystem.LSystem.process_module">process_module</a></code></li>
<li><code><a title="pcgsepy.lsystem.lsystem.LSystem.to_json" href="#pcgsepy.lsystem.lsystem.LSystem.to_json">to_json</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="pcgsepy.lsystem.lsystem.LSystemModule" href="#pcgsepy.lsystem.lsystem.LSystemModule">LSystemModule</a></code></h4>
<ul class="two-column">
<li><code><a title="pcgsepy.lsystem.lsystem.LSystemModule.active" href="#pcgsepy.lsystem.lsystem.LSystemModule.active">active</a></code></li>
<li><code><a title="pcgsepy.lsystem.lsystem.LSystemModule.add_hl_constraint" href="#pcgsepy.lsystem.lsystem.LSystemModule.add_hl_constraint">add_hl_constraint</a></code></li>
<li><code><a title="pcgsepy.lsystem.lsystem.LSystemModule.add_ll_constraint" href="#pcgsepy.lsystem.lsystem.LSystemModule.add_ll_constraint">add_ll_constraint</a></code></li>
<li><code><a title="pcgsepy.lsystem.lsystem.LSystemModule.apply_rules" href="#pcgsepy.lsystem.lsystem.LSystemModule.apply_rules">apply_rules</a></code></li>
<li><code><a title="pcgsepy.lsystem.lsystem.LSystemModule.check_sat" href="#pcgsepy.lsystem.lsystem.LSystemModule.check_sat">check_sat</a></code></li>
<li><code><a title="pcgsepy.lsystem.lsystem.LSystemModule.from_json" href="#pcgsepy.lsystem.lsystem.LSystemModule.from_json">from_json</a></code></li>
<li><code><a title="pcgsepy.lsystem.lsystem.LSystemModule.hl_constraints" href="#pcgsepy.lsystem.lsystem.LSystemModule.hl_constraints">hl_constraints</a></code></li>
<li><code><a title="pcgsepy.lsystem.lsystem.LSystemModule.hlsolver" href="#pcgsepy.lsystem.lsystem.LSystemModule.hlsolver">hlsolver</a></code></li>
<li><code><a title="pcgsepy.lsystem.lsystem.LSystemModule.ll_constraints" href="#pcgsepy.lsystem.lsystem.LSystemModule.ll_constraints">ll_constraints</a></code></li>
<li><code><a title="pcgsepy.lsystem.lsystem.LSystemModule.llsolver" href="#pcgsepy.lsystem.lsystem.LSystemModule.llsolver">llsolver</a></code></li>
<li><code><a title="pcgsepy.lsystem.lsystem.LSystemModule.name" href="#pcgsepy.lsystem.lsystem.LSystemModule.name">name</a></code></li>
<li><code><a title="pcgsepy.lsystem.lsystem.LSystemModule.to_json" href="#pcgsepy.lsystem.lsystem.LSystemModule.to_json">to_json</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>